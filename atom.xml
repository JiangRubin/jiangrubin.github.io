<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiangrubin.github.io</id>
    <title>Rubin&apos;s Blog</title>
    <updated>2020-10-13T03:58:20.084Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiangrubin.github.io"/>
    <link rel="self" href="https://jiangrubin.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiangrubin.github.io/images/avatar.png</logo>
    <icon>https://jiangrubin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Rubin&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[微信小程序开发笔记]]></title>
        <id>https://jiangrubin.github.io/post/wei-xin-xiao-cheng-xu-kai-fa-bi-ji/</id>
        <link href="https://jiangrubin.github.io/post/wei-xin-xiao-cheng-xu-kai-fa-bi-ji/">
        </link>
        <updated>2020-09-27T03:03:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近在开发小程序项目，将项目中遇到的问题和要点记录下来，方便以后查阅。</p>
<h2 id="字体">字体</h2>
<h3 id="全局字体">全局字体</h3>
<p>项目中使用了 <a href="https://vant-contrib.gitee.io/vant-weapp/#/intro">vant-weapp</a>，有赞开源的小程序组件库。</p>
<p>为保证在不同设备上提供最佳的视觉体验，且与组件库风格统一，可在 app.wxss 中设置以下全局字体。</p>
<pre><code class="language-css">page {
  font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Helvetica,
    Segoe UI, Arial, Roboto, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft Yahei',
    sans-serif;
}
</code></pre>
<h3 id="字号单位">字号单位</h3>
<p>字号单位用 px，不同分辨率设备上字体大小保持一致，取值尽量是偶数。</p>
<p>可以将常用的字号写成 css 变量，方便使用。</p>
<pre><code class="language-css">page {
    --font-size-xs: 10px;
    --font-size-sm: 12px;
    --font-size-md: 14px;
    --font-size-lg: 16px;
    --font-size-xl: 18px;
    --font-size-xxl: 24px;
}

view {
    font-size: var(--font-size-md);
}
</code></pre>
<h2 id="图片资源">图片资源</h2>
<p>项目中经常会使用图片、SVG 等文件，而这些文件占据项目体积很大的比重。因小程序包体积限制，需要对图片文件进行压缩处理。</p>
<ul>
<li>
<p><a href="https://tinypng.com/">TinyPNG 图片压缩</a></p>
</li>
<li>
<p><a href="https://www.zhangxinxu.com/sp/svgo/">SVG 在线压缩合并工具</a></p>
</li>
</ul>
<h2 id="wxs-工具方法">WXS 工具方法</h2>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/">WXS</a> 是小程序的一套脚本语言。所说跟 JavaScript 类似但其中有一些坑。比如不能遍历对象。没有 Object 对象，不能使用 <code>for ... in ...</code>。小程序社区里也有关于这个的<a href="https://developers.weixin.qq.com/community/develop/doc/000680569f81100755279069856000?highLine=wxs%2520%25E9%2581%258D%25E5%258E%2586%25E5%25AF%25B9%25E8%25B1%25A1">吐槽</a>。</p>
<p>只能通过正则的方式来实现对象的遍历方法：</p>
<pre><code class="language-js">// object.wxs
var REGEXP = getRegExp('{|}|&quot;', 'g');

function keys (obj) {
  return JSON.stringify(obj)
    .replace(REGEXP, '')
    .split(',')
    .map(function(item) {
      return item.split(':')[0]
    })
}

function values (obj) {
  return JSON.stringify(obj)
    .replace(REGEXP, '')
    .split(',')
    .map(function(item) {
      return item.split(':')[1]
    })
}

module.exports = {
  keys: keys,
  values: values,
}
</code></pre>
<h2 id="iphonex-适配">iPhoneX 适配</h2>
<p>屏幕上边框，右边框，下边框，左边框安全距离：</p>
<pre><code>safe-area-inset-top，
safe-area-inset-right，
safe-area-inset-bottom，
safe-area-inset-left
</code></pre>
<p>使用：</p>
<p>iOS 11</p>
<pre><code class="language-css">padding-top: constant(safe-area-inset-top);
padding-right: constant(safe-area-inset-right);
padding-bottom: constant(safe-area-inset-bottom);
padding-left: constant(safe-area-inset-left);
</code></pre>
<p>iOS 11.2 beta及其后</p>
<pre><code class="language-css">padding-top: env(safe-area-inset-top);
padding-right: env(safe-area-inset-right);
padding-bottom: env(safe-area-inset-bottom);
padding-left: env(safe-area-inset-left);
</code></pre>
<p>兼容性写法：</p>
<pre><code class="language-css">padding-top: constant(safe-area-inset-top);
padding-top: env(safe-area-inset-top);
</code></pre>
<p>参考文档：<a href="https://webkit.org/blog/7929/designing-websites-for-iphone-x/?hmsr=funteas.com&amp;utm_medium=funteas.com&amp;utm_source=funteas.com">苹果官方文档</a></p>
<h2 id="ios-中-promise-对象不存在-finally-方法">iOS 中 Promise 对象不存在 finally 方法</h2>
<p>在开发者工具中没有这个问题，只在 iOS 真机中存在。不知小程序官方是否修复了此 bug。</p>
<p>在 app.js 中添加如下代码：</p>
<pre><code class="language-js">if (!Promise.prototype.finally) {
  Promise.prototype.finally = function (callback) {
    this.then(res =&gt; {
      callback &amp;&amp; callback(res)
    }, error =&gt; {
      callback &amp;&amp; callback(error)
    })
  }
}
</code></pre>
<h2 id="引入路径">引入路径</h2>
<p>在小程序中 <code>import ... from ...</code> 和 <code>require</code> 不支持绝对路径。只能使用相对路径引入，如果目录过深就会写成 <code>../../../../util.js</code>，不够直观优雅。</p>
<p>可以通过以下方式优化引入：</p>
<pre><code class="language-js">// app.js 中
App({
    require (path) {
        return require(`${path}`)
    }
})
</code></pre>
<p>在其他 page 和组件中，就可以统一相对于根路径引入。</p>
<pre><code class="language-js">const app = getApp()
const { formatTime } = app.require('/utils/util')
</code></pre>
<h2 id="sku-商品规格">SKU 商品规格</h2>
<blockquote>
<p>SKU 是值物理上不可分割的最小存货单元</p>
</blockquote>
<p>开发的是电商类型项目，SKU 商品规格选择功能是必不可少的，也是项目中比较复杂的功能。将功能封装为组件，具体的代码查看该<a href="https://github.com/jiangrubin/weapp-sku">地址</a>。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/406936562400.png" alt="" loading="lazy"></figure>
<h3 id="笛卡尔积应用">笛卡尔积应用</h3>
<p>SKU 商品规格选择是 C 端的功能，其中还涉及到如何生成商品 SKU 数据。也就是笛卡尔积的应用。</p>
<p>如上图所示，通过“颜色”和“尺寸”2个销售属性来生成商品的 SKU，就需要对属性的值做笛卡尔积，其中核心代码如下：</p>
<pre><code class="language-js">/**
 * @desc 多数组求笛卡尔积
 * @param { Array } array [['粉色', '黄色', '蓝色'], ['大', '小']]
 * @return { Array } ['粉色', '大'], ['粉色', '小'], ['黄色', '大'], ['黄色', '小'], ['蓝色', '大'], ['蓝色', '小']
 */
function cartesianProduct (array) {
  return array.reduce(function (a, b) {
    return a.map(function (x) {
      return b.map(function (y) {
        return x.concat(y)
      })
    }).reduce(function (a, b) { return a.concat(b) }, [])
  }, [[]])
}
</code></pre>
<h2 id="总结">总结</h2>
<p>这些都是最近项目中记录下来的，欢迎大家交流，以后开发中碰到了其他问题也会持续更新的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法 — 递归]]></title>
        <id>https://jiangrubin.github.io/post/shu-ju-jie-gou-yu-suan-fa-di-gui/</id>
        <link href="https://jiangrubin.github.io/post/shu-ju-jie-gou-yu-suan-fa-di-gui/">
        </link>
        <updated>2020-05-31T07:17:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>递归是算法中一种非常重要的思想，应用非常广泛。是DFS、分治法、回溯、二叉树遍历等方法的基础。先从学习这些方法的基础开始。</p>
<h2 id="什么是递归">什么是递归</h2>
<p>程序调用自身的编程技巧称为递归（ recursion）。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。</p>
<p>像下面这样直接调用自身的函数：</p>
<pre><code class="language-js">function recursion(param){
    recursion(param)
}
</code></pre>
<p>间接调用自身的函数，也是递归函数：</p>
<pre><code class="language-js">function recursion1(param){
    recursion2(param)
}

function recursion2(param){
    recursion1(param)
}
</code></pre>
<p>假设现在执行 recursion 函数，就上述情况而言，其会一直执行下去。因此，每个递归函数都必须要有边界条件，即一个不再递归调用的条件，以防止无限递归。</p>
<p>如果忘记加上用以停止函数递归调用的边界条件，在浏览器中执行，递归并不会无限地执行下去，浏览器会抛出错误 <code>Maximum call stack size exceeded</code> 也就是所谓的栈溢出。</p>
<p>以阶乘为例，体会一下递归：</p>
<pre><code class="language-js">function factorial(n) {
    if (n &lt;= 1) {
        return 1
    }
    return n * factorial(n - 1)
}

factorial(6) // 6 * 5 * 4 * 3 * 2 * 1 = 720
</code></pre>
<p>factorial 是一个实现阶乘的函数，来看下它的调用过程。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1590918559854.jpg" alt="" loading="lazy"></figure>
<p>从这个例子中可以看出，阶乘中的 <code>n &lt;= 1</code> 是边界条件，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。构成递归需具备边界条件、递归前进段和递归返回段。</p>
<h2 id="斐波那契数列">斐波那契数列</h2>
<p>斐波那契指的是这样一个数列：1、1、2、3、5、8、13、21、34 ...，这个数列从第3项开始，每一项都等于前两项之和。</p>
<h3 id="递归实现">递归实现</h3>
<pre><code class="language-js">function fibonacci(n) {
    if (n &lt;= 2) {
        return 1
    }
    return fibonacci(n - 1) + fibonacci(n - 2)
}

console.log(fibonacci(6)) // 8
</code></pre>
<p>但是当参数 n 变大时，浏览器卡死了。原因是此函数中存在着大量的冗余计算，并且 n 越大，冗余的越多。如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1590919586864.png" alt="" loading="lazy"></figure>
<p>图中每个分支上的函数都是单独调用的，并且都是重复的调用，针对这种冗余计算，我们可以做相关的优化，优化的思路都是减少相同函数的重复调用。</p>
<h3 id="迭代实现">迭代实现</h3>
<pre><code class="language-js">function fibonacci(num){
    var n1 = 1,
    n2 = 1,
    n = 1;
    for (var i = 3; i &lt;= num; i++){
        n = n1 + n2;
        n1 = n2;
        n2 = n;
    }
    return n;
} 
</code></pre>
<h3 id="尾调用优化">尾调用优化</h3>
<pre><code class="language-js">function fibonacci (n, res1 = 1, res2 = 1) {
    if (n &lt;= 2) {
        return res2
    }
    return fibonacci(n - 1, res2, res1 + res2)
}
</code></pre>
<h2 id="应用场景">应用场景</h2>
<p>一些 JavaScript 的工具方法中涉及到了递归。</p>
<h3 id="深拷贝">深拷贝</h3>
<pre><code class="language-js">function deepCopy (data) {
    // 数据类型判断函数，见下
    const t = typeOf(data)
    let o

    if (t === 'array') {
        o = []
    } else if (t === 'object') {
        o = {}
    } else {
        return data
    }

    for (var key in data) {
        o[key] = deepCopy(data[key])
    }

    return o
}

function typeOf (obj) {
    const toString = Object.prototype.toString
    const map = {
        '[object Boolean]': 'boolean',
        '[object Number]': 'number',
        '[object String]': 'string',
        '[object Function]': 'function',
        '[object Array]': 'array',
        '[object Date]': 'date',
        '[object RegExp]': 'regExp',
        '[object Undefined]': 'undefined',
        '[object Null]': 'null',
        '[object Object]': 'object'
    }
    return map[toString.call(obj)]
}
</code></pre>
<h3 id="数组扁平化">数组扁平化</h3>
<pre><code class="language-js">function flatten(arr) {
    return arr.reduce(function(prev, next){
        return prev.concat(Array.isArray(next) ? flatten(next) : next)
    }, [])
}
</code></pre>
<h2 id="总结">总结</h2>
<p>学习了递归的基本使用和实现了 JavaScript 中常用的工具方法。关于递归的内容还有很多，比如还有汉诺塔、二叉树遍历等递归场景。算法之路漫漫 😬。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法 — 排序]]></title>
        <id>https://jiangrubin.github.io/post/shu-ju-jie-gou-yu-suan-fa-pai-xu/</id>
        <link href="https://jiangrubin.github.io/post/shu-ju-jie-gou-yu-suan-fa-pai-xu/">
        </link>
        <updated>2020-04-27T11:41:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>程序 = 数据结构 + 算法</p>
</blockquote>
<p>要想在编程之路走的更远，学好数据结构与算法很重要。所以把学习的总结写成一个系列，使用自己熟悉的 JavaScript 语言，旨在入门数据结构与算法和方便以后复习。</p>
<p>先从算法领域里基础的排序算法开始。</p>
<h2 id="经典排序算法对比">经典排序算法对比</h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588420187412.jpg" alt="" loading="lazy"></figure>
<p><strong>名词解释：</strong></p>
<p><strong>n</strong>: 待排序列的个数<br>
<strong>k</strong>: “桶”的个数<br>
<strong>In-place</strong>: 原地算法，指的是占用常用内存，不占用额外内存。空间复杂度为 O(1) 的都可以认为是原地算法<br>
<strong>Out-place</strong>: 非原地算法，占用额外内存<br>
<strong>稳定性</strong>：排序后2个相等键值的顺序和排序之前它们的顺序相同</p>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><strong>算法描述：</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588422112893.gif" alt="" loading="lazy"></figure>
<p><strong>代码实现：</strong></p>
<pre><code class="language-js">function bubbleSort(array) {
    var length = array.length
    for (var i = 0; i &lt; length; i++) {
        // length - 1 - i 从内循环减去外循环中已跑过的轮数，就可以避免内循环中所有不必要的比较
        for (var j = 0; j &lt; length - 1 - i; j++) {
            // 如果当前项比下一项大，则使用中间值进行交换
            if (array[j] &gt; array[j + 1]) {
                var temp = array[j] 
                array[j] = array[j + 1]
                array[j + 1] = temp
            }
        }
    }
    return array
}

bubbleSort([3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48])
// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre>
<h2 id="选择排序">选择排序</h2>
<p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并<br>
将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588422191480.gif" alt="" loading="lazy"></figure>
<p><strong>代码实现：</strong></p>
<pre><code class="language-js">function selectionSort (array) {
    var length = array.length
    var minIndex, temp
    for (var i = 0; i &lt; length - 1; i ++) {
        minIndex = i // 假设本次循环的第一个值为数组最小值
        for (var j = i + 1; j &lt; length; j++) {
            // 比较位置j的值是否比当前最小值小
            if (array[j] &lt; array[minIndex]) {
                minIndex = j // 如果是，则改变最小值的索引
            }
        }
        // 如果该最小值和原最小值不同，则交换其值
        if (i !== minIndex) {
            temp = array[i]
            array[i] = array[minIndex]
            array[minIndex] = temp
        }
    }
    return array
}

selectionSort([3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48])
// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre>
<p>选择排序同样也是一个复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的算法。和冒泡排序一样，它包含有嵌套的两个循环，这导致了二次方的复杂度。</p>
<h2 id="插入排序">插入排序</h2>
<p>插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。取第二项向前进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588422221669.gif" alt="" loading="lazy"></figure>
<p><strong>代码实现：</strong></p>
<pre><code class="language-js">function insertionSort (array) {
    var length = array.length
    var j, temp
    // 是从第二个位置（索引1）而不是0位置开始的（假定第一项已排序了）
    for (var i = 1; i &lt; length; i ++) {
        // 用i的值来初始化一个辅助变量并将其值亦存储于一临时变量中，便于之后将其插入到正确的位置上
        j = i
        temp = array[i]
        // 要变量j比0大，并且数组中前面的值比待比较的值大
        // 就把这个值移到当前位置上并减小j
        while (j &gt; 0 &amp;&amp; array[j - 1] &gt; temp) {
            array[j] = array[j - 1]
            j--
        }
        array[j] = temp
    }
    return array
}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一<br>
个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588422563704.gif" alt="" loading="lazy"></figure>
<p><strong>代码实现：</strong></p>
<pre><code class="language-js">function mergeSort (array) {
    var length = array.length
    // 由于算法是递归，需要一个停止条件
    if (length &lt;= 1) {
        return array
    }
    // 如果数组长度大于1，首先是找到数组的中间位，之后将数组分成left、right两个小数组
    var mid = Math.floor(length / 2)
    var left = array.slice(0, mid)
    var right = array.slice(mid)
    // 调用merge函数，它负责合并和排序小数组来产生大数组
    // 为了不断将原始数组分成小数组，我们得再次对left数组和right数组递归调用mergeSort，并同时作为参数传递给merge函数
    return merge(mergeSort(left), mergeSort(right))
}

function merge (left, right) {
    // 声明归并过程要创建的新数组以及用来迭代两个数组（left和right）所需的两个变量
    var result = [], il = 0, ir = 0
    // 迭代两个数组的过程中，比较两个数组的项大小。将小的一方添加至结果数组，并递增迭代数组的控制变量
    while (il &lt; left.length &amp;&amp; ir &lt; right.length) {
        if (left[il] &lt; right[ir]) {
            result.push(left[il++])
        } else {
            result.push(right[ir++])
        }
    }
    // 接下来，分别将两个数组剩余的项添加到结果数组中
    while (il &lt; left.length) {
        result.push(left[il++])
    }
    while (ir &lt; right.length) {
        result.push(right[ir++])
    }
    return result;
}

mergeSort([3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48])
</code></pre>
<p>归并排序性能不错，其复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n log^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="快速排序">快速排序</h2>
<p>快速排序是最快的排序算法之一，它的复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组。</p>
<p><strong>算法描述：</strong></p>
<ol>
<li>从数组中选择中间一项作为“主元”（pivot）。</li>
<li>创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指<br>
针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交<br>
换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之<br>
前，而比主元大的值都排在主元之后。这一步叫作划分操作（partition）。</li>
<li>算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的<br>
子数组）重复之前的两个步骤，直至数组已完全排序。</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588422728358.gif" alt="" loading="lazy"></figure>
<p><strong>代码实现：</strong></p>
<pre><code class="language-js">function quickSort(array) {
    // 传递待排序数组，以及索引0及其最末的位置（因为我们要排整个数组，而不是一个子数组）作为参数
    return quick(array, 0, array.length - 1)
}

function quick(array, left, right) {
    // 声明index变量，用于帮助我们将子数组分离为较小值数组和较大值数组
    var index
    if (array.length &gt; 1) {
        index = partition(array, left, right)
        // 划分为两个子数组重复快速排序过程
        if (left &lt; index - 1) {
            quick(array, left, index - 1)
        }
        if (index &lt; right) {
            quick(array, index, right)
        }
    }
    return array
}

function partition(array, left, right) {
    // 选择中间项作为主元，初始化两个指针：数组第一个元素、数组最后一个元素
    var pivot = array[Math.floor((left + right) / 2)],
        l = left,
        r = right;

    // 只要left和right指针没有相互交错，就执行划分操作
    while (l &lt;= r) {
        // 移动left指针直到找到一个元素比主元大
        while (array[l] &lt; pivot) {
            l++
        }
        // 移动right指针直到找到一个元素比主元小
        while (array[r] &gt; pivot) {
            r--
        }
        // 当左指针指向的元素比主元大且右指针指向的元素比主元小，并且此时左指针索引没有右指针索引大，则交换它们，然后移动两个指针，并重复此过程继续循环。
        if (l &lt;= r) {
            var temp = array[l]
            array[l] = array[r]
            array[r] = temp;
            l++
            r--
        }
    }
    // 在划分操作结束后，返回左指针的索引，用来处创建子数组
    return l
}

quickSort([3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48])
</code></pre>
<h2 id="堆排序">堆排序</h2>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588500046422.gif" alt="" loading="lazy"></figure>
<p><strong>代码实现：</strong></p>
<pre><code class="language-js">function heapSort(array) {
    var heapSize = array.length
    for (var i = Math.floor(heapSize / 2); i &gt;= 0; i--) {
        heapify(array, heapSize, i)
    }
    while (heapSize &gt; 1) {
        heapSize--
        swap(array, 0, heapSize)
        heapify(array, heapSize, 0)
    }
    return array
}

function heapify(array, heapSize, i) {
    var left = i * 2 + 1,
        right = i * 2 + 2,
        largest = i;
    if (left &lt; heapSize &amp;&amp; array[left] &gt; array[largest]) {
        largest = left;
    }
    if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) {
        largest = right;
    }
    if (largest !== i) {
        swap(array, i, largest);
        heapify(array, heapSize, largest);
    }
}

function swap(arr, i, j) {
    var temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

heapSort([3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48])
</code></pre>
<!-- ## 计数排序    

![](https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588423003529.gif)

## 桶排序

## 基数排序

![](https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1588423067487.gif) -->
<h2 id="总结">总结</h2>
<p>感慨算法实在是博大精深，前辈们花费心血研究出的成果值得我们学习和推敲。排序算法还有计数排序、桶排序和基数排序，实在没精力去一一研究了😓。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 证书配置指北]]></title>
        <id>https://jiangrubin.github.io/post/ios-zheng-shu-pei-zhi-zhi-bei/</id>
        <link href="https://jiangrubin.github.io/post/ios-zheng-shu-pei-zhi-zhi-bei/">
        </link>
        <updated>2020-04-06T02:16:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>用 react-native 开发项目时，在对 iOS 证书相关的配置，每次操作一遍后过一段时间又忘了。所以将证书的配置流程都记录下来，方便以后查阅。</p>
<h2 id="创建应用程序-id">创建应用程序 ID</h2>
<p>首先需要开发者账号，登录<a href="https://developer.apple.com/" target="_blank">苹果开发者网站</a>进入开发者账户。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586741039119.png" alt="" loading="lazy"></figure>
<p>进入 <code>Certificates, Identifiers &amp; Profiles</code> 页面。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586141548388.png" alt="" loading="lazy"></figure>
<p>选择 Identifiers 创建 App ID，填写 App ID 的 Description 和 Bundle ID。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586141828211.png" alt="" loading="lazy"></figure>
<p>一般选择 App IDs 即可。</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586141936519.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586142154922.png" alt="" loading="lazy"></figure>
<p>为 App 添加一些功能，比如消息推送功能。</p>
<figure data-type="image" tabindex="6"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586142360020.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586142366600.png" alt="" loading="lazy"></figure>
<p>填写好以上信息后，点击 Continue，确认 AppId 正确填写，点击 Register，注册 AppId 成功。</p>
<h2 id="创建-csr-文件证书请求文件">创建 CSR 文件（证书请求文件）</h2>
<blockquote>
<p>CSR（Certificate Signing Request）即证书请求文件。证书申请者在申请数字证书时由 CSP（加密服务提供者）在生成私钥的同时也生成证书请求文件（CSR 文件），证书申请者只要把 CSR 文件提交给证书颁发机构后（创建 App ID 时上传到苹果后台），证书颁发机构使用其根证书私钥签名生成证书公钥文件（开发者证书）。</p>
</blockquote>
<p>CSR 文件在创建 Certificates 时需要上传。</p>
<p>使用 Mac 自带的 <code>钥匙串访问</code> 来创建 <code>Certificate Signing Request</code> 文件，如下图操作：</p>
<figure data-type="image" tabindex="8"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586143369160.png" alt="" loading="lazy"></figure>
<p>填写 <code>用户邮箱</code> 和 <code>常用名称</code> (名称可以随意填)，并选择 <code>存储到磁盘</code>，文件后缀为 <code>.certSigningRequest</code>。</p>
<figure data-type="image" tabindex="9"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586143624913.png" alt="" loading="lazy"></figure>
<h2 id="创建证书">创建证书</h2>
<blockquote>
<p>iOS 证书是用来证明 iOS App 内容（executable code）的合法性和完整性的数字证书。对于想安装到真机或发布到 AppStore 的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证 App 内容是完整、未经篡改的。</p>
</blockquote>
<p>选择 Certificates 点击加号。</p>
<figure data-type="image" tabindex="10"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586144322541.png" alt="" loading="lazy"></figure>
<p>选择相应的证书种类，如图有开发调试证书、生产发布证书（App Store 上传应用商店、Ad Hoc 用于测试包发布）、开发环境推送证书、生产环境推送证书。选择你需要的证书。</p>
<figure data-type="image" tabindex="11"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586236889292.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586236895832.png" alt="" loading="lazy"></figure>
<p>再点击 Continue，选择之前生成的 CSR 文件上传，继续点击 Continue，证书创建完成。下载下来添加到钥匙串访问中。</p>
<figure data-type="image" tabindex="13"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586229786987.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586229914720.png" alt="" loading="lazy"></figure>
<h3 id="推送证书和极光推送">推送证书和极光推送</h3>
<p>项目中需要消息推送服务的话，就需要用的消息推送证书。我使用的是极光推送，把消息推送证书 Download 下来，双击添加到钥匙串访问中。找到刚才下载的证书并导出 <code>.p12</code> 文件，之后需要添加到极光后台。</p>
<figure data-type="image" tabindex="15"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586235903947.png" alt="" loading="lazy"></figure>
<p>点击存储后需要输入密码，密码要记住，上传到极光后台需要用到。</p>
<figure data-type="image" tabindex="16"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586236061023.png" alt="" loading="lazy"></figure>
<p>假设你的极光后台应用信息已经填写好，设置证书时如下图：</p>
<figure data-type="image" tabindex="17"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586236293643.png" alt="" loading="lazy"></figure>
<p>上传之前导出的 <code>.p12</code> 文件，填写导出时设置的密码，极光会在后台为你的应用进行鉴权。</p>
<figure data-type="image" tabindex="18"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586236303663.png" alt="" loading="lazy"></figure>
<h2 id="创建配置文件">创建配置文件</h2>
<p>创建 Provisioning Profile 的前提，已在 Apple Developer 网站创建待发布应用所使用的 Bundle ID 的 App ID。</p>
<p>选择 Profile 点击加号按钮，创建 Provisioning Profile。</p>
<figure data-type="image" tabindex="19"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586230645086.png" alt="" loading="lazy"></figure>
<p>选择你需要的 Profile 环境。</p>
<figure data-type="image" tabindex="20"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586237441979.png" alt="" loading="lazy"></figure>
<p>选择之前创建的 App ID、相应的证书、测试的设备、profile 名称，一直 Continue 即可。</p>
<figure data-type="image" tabindex="21"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586231384208.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="22"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586231669480.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586231591517.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="24"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586234979603.png" alt="" loading="lazy"></figure>
<p>填写完 Profile Name 点击 generate 完成，之后点击 DownLoad，下载 <code>.mobileprovision</code> 的文件，双击文件即可添加到 Xcode。</p>
<figure data-type="image" tabindex="25"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1586235137886.png" alt="" loading="lazy"></figure>
<p>至此证书和配置文件之类的都创建完了。</p>
<h2 id="其他问题">其他问题</h2>
<h3 id="xcode-missing-private-key-解决方案">Xcode Missing Private key 解决方案</h3>
<p>当我们换另一台 Mac 设备开发打包的时候，会发现提示 <code>Missing Private key</code>。</p>
<p>因为苹果规定 <code>.cer</code> 证书只能存在于一台机器上，因此如果另一台电脑想要用的话，需要导出为 <code>.p12</code> 文件，安装到另一台没有安装 <code>.cer</code> 文件的 Mac 电脑。</p>
<p>详细说明参考该篇博客 <a href="https://www.jianshu.com/p/6372055fbaa0" target="_blank">https://www.jianshu.com/p/6372055fbaa0</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 源码分析 — 响应式原理]]></title>
        <id>https://jiangrubin.github.io/post/vue-yuan-ma-fen-xi-xiang-ying-shi-yuan-li/</id>
        <link href="https://jiangrubin.github.io/post/vue-yuan-ma-fen-xi-xiang-ying-shi-yuan-li/">
        </link>
        <updated>2020-03-15T11:50:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>Vue 是目前流行前端框架，其独特的特性是其非侵入性的响应式系统。当侦测到数据的变化来更新视图，原理核心是使用 <code>Object.defineProperty</code> 方法。本文对响应式原理进行分析，参照 vue 源码实现简易版的数据响应式。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1584274877854.png" alt="" loading="lazy"></figure>
<h2 id="代码实现">代码实现</h2>
<p>本文完整代码点击<a href="https://github.com/jiangrubin/vue-mine" target="_blank">这里</a></p>
<pre><code class="language-js">import { def, isObject } from '../util/index'

class Observer {
  constructor (value) {
    this.value = value
    // 通过 defineProperty 为对象添加 __ob__ 属性，并且配置为不可枚举
    // 这样做的意义是对象遍历时不会遍历到 __ob__ 属性
    def(value, '__ob__', this)
    this.walk(value)
  }

  walk (obj) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }
}

function defineReactive (obj, key, val) {
  // 如果 val 是对象的话递归监听
  observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true, // 可枚举
    configurable: true, // 可配置
    get: function reactiveGetter () {
      return val
    },
    set: function reactiveSetter (newVal) {
      if (newVal === val || (newVal !== newVal &amp;&amp; val !== val)) {
        return
      }
      val = newVal
      // 如果赋值是对象的话也要递归监听
      observe(newVal)
      console.log('侦测到数据变化', newVal);
    }
  })
}

export function observe (value) {
  // 类型判断，不是对象类型直接返回
  if (!isObject(value)) {
    return
  }
  let ob = new Observer(value)
  return ob
}
</code></pre>
<p>上面这段代码主要作用在于：<code>observe</code> 函数传入一个 <code>value</code> (需要被追踪变化的对象)，作为 <code>Observer</code> 类的参数实例化，遍历所有属性对该对象的每一个属性都通过 <code>defineReactive</code> 处理， 在 <code>defineReactive</code> 方法内 <code>observe</code> 会进行递归调用，以此来达到实现侦测对象变化。</p>
<p>接下来实现 <code>Vue</code> 类，对 options 中的 data 传入 observe 开发进行初始化数据侦测。</p>
<pre><code class="language-js">import { observe } from '../observer/index'

const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: function () {},
  set: function () {}
}

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

function Vue (options) {
  let vm = this
  let data = options.data
  vm._data = data

  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    // 可以让 vm._data.x 通过 vm.x 访问
    proxy(vm, `_data`, key)
  }

  observe(data)
}

export default Vue
</code></pre>
<p>实例化 Vue 类，查看控制台的输出 vm。</p>
<pre><code class="language-js">import Vue from './instance/index'

const vm = new Vue({
  data: {
    message: 'hello',
    location: { x: 100, y: 100 },
    arr: [1]
  }
})

window.vm = vm

// 在控制台输入： vm.location = { x: 10, y: 10 } 
// 输出：侦测到数据变化 {__ob__: Observer}
// 输入：vm.location.z = 10
// 输出：10
// 输入：vm.arr.push(2)
// 输出：2
</code></pre>
<p>从中可以看到几个问题：</p>
<ul>
<li>无法检测到对象属性的添加或删除</li>
</ul>
<p>通过 <code>Object.defineProperty</code> 来将对象的key转换成 <code>getter/setter</code> 的形式来追踪变化，但 <code>getter/setter</code> 只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。</p>
<p>实现 Vue 提供的 <code>set</code> 和 <code>delete</code> 方法向嵌套对象添加/删除响应式属性。</p>
<ul>
<li>不能监听数组的变化，需要进行数组方法的重写</li>
</ul>
<p>解决以上问题，具体代码如下：</p>
<pre><code class="language-js">// array.js
// 获得数组原型
const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)
// 创建一个自己的原型 并且重写 methods 这些方法
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

methodsToPatch.forEach(function (method) {
  const original = arrayProto[method]
  arrayMethods[method] = function (...args) {
    const result = original.apply(this, args)
    return result
  }
})
</code></pre>
<p>在 <code>observer/index.js</code> 中导入 <code>arrayMethods</code> 重写的原型对象。</p>
<pre><code class="language-js">import { arrayMethods } from './array'
import { def, isObject } from '../util/index'

class Observer {
  constructor (value) {
    this.value = value
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      value.__proto__ = arrayMethods
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  walk (obj) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i], obj[keys[i]])
    }
  }

  observeArray (items) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])
    }
  }
}
</code></pre>
<p>以上代码实现了数据劫持，接下来需要实现收集依赖以及数据更新时派发更新，其中的核心思想就是<code>发布-订阅模式</code>。关于订阅者 <code>Dep</code> 和观察者 <code>Watcher</code> 相关代码。</p>
<p><strong>订阅者 Dep</strong></p>
<pre><code class="language-js">import { remove } from '../util/index'

export default class Dep {
  constructor () {
    /* 用来存放 Watcher 对象的数组 */
    this.subs = []
  }

  /* 在 subs 中添加一个 Watcher 对象 */
  addSub (sub) {
    this.subs.push(sub)
  }

  removeSub (sub) {
    remove(this.subs, sub)
  }
  
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  /* 通知所有 Watcher 对象更新视图 */
  notify () {
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}

/* 在 watcher.js 中调用，将 Watcher 实例赋值给 Dep.target */ 
Dep.target = null
</code></pre>
<p><strong>观察者 Watcher</strong></p>
<pre><code class="language-js">import Dep from './dep'

export default class Watcher {
  constructor (vm, expOrFn, cb) {
    this.vm = vm
    this.getter = expOrFn || function () {}
    this.cb = cb
    this.value = this.get()
  }

  get () {
    Dep.target = this

    const vm = this.vm
    let value = this.getter.call(vm, vm)
    return value
  }

  addDep(dep) {
    dep.addSub(this)
  }

  update () {
    console.log('更新value:', this.value)
  }
}
</code></pre>
<p>在执行构造函数的时候将 <code>Dep.target</code> 指向自身，从而使得收集到了对应的 <code>Watcher</code>，在派发更新的时候取出对应的 <code>Watcher</code>，然后执行 <code>update</code> 函数。</p>
<p>最后对 <code>defineReactive</code> 函数和 <code>Vue</code> 类进行改造</p>
<pre><code class="language-js">export function defineReactive (obj, key, val) {
  const dep = new Dep()
  let childOb = observe(val)
  
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // 将 Watcher 添加到订阅  
      dep.depend()
      return val
    },
    set: function reactiveSetter (newVal) {
      if (newVal === val || (newVal !== newVal &amp;&amp; val !== val)) {
        return
      }
      val = newVal
      childOb = observe(newVal)
      // 执行 watcher 的 update 方法
      dep.notify()
    }
  })
}
</code></pre>
<pre><code class="language-js">function Vue (options) {
  let vm = this
  let data = options.data
  vm._data = data

  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    proxy(vm, `_data`, key)
  }

  observe(data)
  /* 新建一个 Watcher 观察者对象，这时候 Dep.target 会指向这个 Watcher 对象 */
  new Watcher(data, val =&gt; val)
}
</code></pre>
<p>当 render function 被渲染的时候，读取所需对象的值，会触发 reactiveGetter 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果修改对象的值，则会触发 reactiveSetter 方法，通知 Dep 类调用 notify 来触发所有 Watcher 对象的 update 方法更新对应视图。</p>
<h2 id="总结">总结</h2>
<p>本文在阅读 Vue 源码后，根据自己的理解加上参考其他文章，编写的一个精简代码实现。其中代码实现并不严谨以及自身的理解不到位，在此深表惭愧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub Actions 自动部署实践]]></title>
        <id>https://jiangrubin.github.io/post/github-actions-zi-dong-bu-shu-shi-jian/</id>
        <link href="https://jiangrubin.github.io/post/github-actions-zi-dong-bu-shu-shi-jian/">
        </link>
        <updated>2020-02-13T11:16:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>GitHub Actions 是 GitHub 推出的持续集成服务，语法介绍可以看 <a href="https://github.com/features/actions" target="_blank">官方文档</a> 或者 <a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank">阮一峰老师的博客</a>。于是本着折腾的心思来自动发布一个 vue 应用到自己的 GitHub Pages。</p>
<h2 id="创建项目">创建项目</h2>
<p>使用 <a href="https://cli.vuejs.org/zh/" target="_blank">vue-cli</a> 创建一个简单的 vue 项目</p>
<pre><code>vue create github-actions-demo
</code></pre>
<blockquote>
<p>Vue Router 不要选择 History 模式，发布到 github page 是一个纯前端静态页面，而 History 模式需要后台配置支持。</p>
</blockquote>
<p>项目创建完成后，还需要在 <code>vue.config.js</code> 中设置正确的 <code>publicPath</code>。</p>
<p>如果打算将项目部署到 <code>https://&lt;USERNAME&gt;.github.io/</code> 上，<code>publicPath</code> 默认为 <code>&quot;/&quot;</code> 可以忽略这个参数。</p>
<p>如果打算将项目部署到 <code>https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/</code> 上（即仓库地址为 <code>https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;</code>），将 <code>publicPath</code> 设为 <code>&quot;/&lt;REPO&gt;/&quot;</code>。举个例子，如果仓库名字为 “my-project”，那么 <code>vue.config.js</code> 的内容应如下所示：</p>
<pre><code class="language-js">module.exports = {
  publicPath: process.env.NODE_ENV === 'production'
    ? '/my-project/'
    : '/'
}
</code></pre>
<h2 id="准备工作">准备工作</h2>
<p>创建一个 GitHub 仓库，以及配置 GitHub 密钥。</p>
<ol>
<li>
<p>申请一个 access tokens</p>
<p>点击头像 <code>Setting</code> &gt; <code>Developer setttings</code> &gt; <code>Personal access tokens</code></p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1581598562909.jpeg" alt="" loading="lazy"></figure>
<p>点击 <code>Generate new token</code> 按钮，勾选好权限生成 token，记下生成的 token 之后需要用到。</p>
</li>
<li>
<p>在创建的仓库中点击  <code>Settings</code> &gt; <code>Secrets</code> &gt; <code>Add a new secret</code></p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1581598887444.png" alt="" loading="lazy"></figure>
<p>Name 随意填写，Value 填入刚申请的 token 值</p>
</li>
</ol>
<h2 id="编写-yml-文件">编写 yml 文件</h2>
<pre><code class="language-yml">name: GitHub Actions Build and Deploy Demo
on:
  push:
    branches:
      - master # 整个流程在master分支发生push事件时触发
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@master

    - name: Build and Deploy
      uses: JamesIves/github-pages-deploy-action@releases/v2
      env:
        ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }} # 密钥
        BRANCH: gh-pages # 发布分支
        FOLDER: dist # vue-cli build 后的目录
        BUILD_SCRIPT: npm install &amp;&amp; npm run build # 构建脚本
</code></pre>
<h2 id="最后工作">最后工作</h2>
<p>保存文件后，将整个仓库推送到 GitHub，完整的 <a href="https://github.com/jiangrubin/github-actions-demo" target="_blank">代码仓库</a> 在这里。</p>
<p>Actions 开始自动运行，接着等待它完成。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1581599890441.jpeg" alt="" loading="lazy"></figure>
<p>等 workflow 运行结束，访问 <a href="https://jiangrubin.github.io/github-actions-demo/#/" target="_blank">GitHub Page</a> 就可以看到页面了。</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1581600153643.png" alt="" loading="lazy"></figure>
<p>以后，每次修改后推送源码，GitHub Actions 都会自动运行，将构建产物发布到网页。</p>
<blockquote>
<p>GitHub Page 会有生效时间，在 Settings 中 GitHub Pages 看到配置如下时就可以正常访问了。</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1581600456035.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git Commit Message 规范化实践]]></title>
        <id>https://jiangrubin.github.io/post/git-commit-message-gui-fan-hua-shi-jian/</id>
        <link href="https://jiangrubin.github.io/post/git-commit-message-gui-fan-hua-shi-jian/">
        </link>
        <updated>2020-02-06T03:21:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在多人协作开发项目时，如果没有规范约束 git commit message，容易造成各种提交的风格五花八门。而规范的提交信息能让他人快速了解此次提交的目的，还可以有效的输出 CHANGELOG，对项目的管理至关重要。</p>
<h2 id="commit-message-的格式">Commit message 的格式</h2>
<p>目前应用比较广泛的是 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" target="_blank">Angular 团队的规范</a>，它的 message 格式如下：</p>
<pre><code class="language-xml">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;
</code></pre>
<p><code>type</code> 用于说明 commit 的类别，可以使用如下：</p>
<ul>
<li>feat：新功能</li>
<li>fix：修复 bug</li>
<li>docs：文档修改</li>
<li>style：代码格式（不影响代码运行的变动）</li>
<li>refactor：代码重构（即不是新增功能，也不是修改 bug 的代码变动）</li>
<li>perf：优化相关，比如提升性能、体验</li>
<li>test：增加测试</li>
<li>revert：回滚</li>
<li>chore：其他修改，比如构建流程、依赖管理</li>
<li>...</li>
</ul>
<p><code>scope</code> 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同</p>
<p><code>subject</code> 是 commit 目的的简短描述</p>
<p><code>body</code> 是对本次 commit 的详细描述，可以分成多行</p>
<p><code>footer</code> 一些备注，通常是 BREAKING CHANGE 或修复的 bug 的链接</p>
<h2 id="commitizen">Commitizen</h2>
<p>了解规范格式后，就需要通过 <a href="https://github.com/commitizen/cz-cli" target="_blank">Commitizen</a> 借助它提供的 git cz 命令替代我们的 git commit 命令，帮助我们生成符合规范的 commit message。</p>
<p>推荐在本地安装的方式</p>
<pre><code>npm install commitizen --save-dev
</code></pre>
<p>接着为 commitizen 初始化 Adapter</p>
<p>在 npm 5.2+ 你可以使用 <a href="http://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank">npx</a> 来初始化 Adapter</p>
<pre><code>npx commitizen init cz-conventional-changelog --save-dev --save-exact
</code></pre>
<blockquote>
<p>npm &lt; 5.2 可以执行 <code>./node_modules/.bin/commitizen</code> 或者 <code>./node_modules/.bin/git-cz</code></p>
</blockquote>
<p>并在 package.json 中添加 npm scripts 运行脚本</p>
<p>package.json 会新增如下配置：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;commit&quot;: &quot;git-cz&quot;
},
&quot;devDependencies&quot;: {
    &quot;commitizen&quot;: &quot;^4.0.3&quot;,
    &quot;cz-conventional-changelog&quot;: &quot;^3.1.0&quot;,
},
&quot;config&quot;: {
    &quot;commitizen&quot;: {
      &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;
    }
}
</code></pre>
<p>之后就可以在项目中执行 <code>npm run commit</code> 或者 <code>npx git cz</code>，效果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1580967235373.jpeg" alt="" loading="lazy"></figure>
<h2 id="standard-version-自动生成-changelog">standard-version: 自动生成 CHANGELOG</h2>
<p>使用工具后我们的工程 commit message 应该是符合 Angular 团队那套，这样也便于我们借助 <a href="https://github.com/conventional-changelog/standard-version" target="_blank">standard-version</a> 这样的工具，自动生成 CHANGELOG。</p>
<p>本地安装</p>
<pre><code class="language-shell">npm install standard-version --save-dev
</code></pre>
<p>在 package.json 添加运行脚本</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;release&quot;: &quot;standard-version&quot;
  }
}
</code></pre>
<p>运行脚本后，效果大致如下：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1580970514212.jpeg" alt="" loading="lazy"></figure>
<p>更多使用特性详见其<a href="https://github.com/conventional-changelog/standard-version" target="_blank">文档</a></p>
<h2 id="结语">结语</h2>
<p>查看完整的 <a href="https://github.com/jiangrubin/standard-commit" target="_blank">demo</a></p>
<p>此文是适合自己的一个简单通用配置，如使用 commitlint 更严格的校验 message 以及其他自定义配置，可见以下参考资料中的链接</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://juejin.im/post/5afc5242f265da0b7f44bee4" target="_blank">优雅的提交你的 Git Commit Message</a></p>
</li>
<li>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank">Commit message 和 Change log 编写指南</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[scrollIntoView 实现页面锚点]]></title>
        <id>https://jiangrubin.github.io/post/scrollintoview-shi-xian-ye-mian-mao-dian/</id>
        <link href="https://jiangrubin.github.io/post/scrollintoview-shi-xian-ye-mian-mao-dian/">
        </link>
        <updated>2020-01-30T03:12:12.000Z</updated>
        <summary type="html"><![CDATA[<p>锚点即指 html 中的链接，在页面中适当的添加锚点可以大大提高阅读或查找效率</p>
]]></summary>
        <content type="html"><![CDATA[<p>锚点即指 html 中的链接，在页面中适当的添加锚点可以大大提高阅读或查找效率</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>锚点是网站中常用的功能。前端简单实现锚点的方法，使用 a 标签把 href 属性写成要跳转到的元素 id，比如以下代码：</p>
<pre><code class="language-html">&lt;a href=&quot;#anchor&quot;&gt;&lt;/a&gt;

&lt;div id=&quot;anchor&quot;&gt;&lt;/div&gt;
</code></pre>
<p>点击 a 标签页面就会跳转到指定 id 元素的位置。并改变链接地址比如：<code>http://www.xxxx.com#anchor</code>。</p>
<p>虽然不会有什么问题，直接跳转过去立马完成产品的需求，但是当网页中存在多个锚点时，就会出现点击浏览器后退按钮并不会返回之前浏览的网页，而是返回上一个带有锚点的链接。</p>
<blockquote>
<p>举个例子，当前网站链接是 <code>http://www.xxxx.com#anchor2</code>， 当用户想返回之前的页面，点击后退按钮后，链接变成了 <code>http://www.xxxx.com#anchor1</code>。但还是在同一个页面中，会使用户感到迷惑，降低用户体验。</p>
</blockquote>
<h2 id="解决问题">解决问题</h2>
<p><code>scrollIntoView()</code> 方法让当前的元素滚动到浏览器窗口的可视区域内，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView">MDN</a> 对此方法介绍。</p>
<p>简单代码实现：</p>
<pre><code class="language-html">&lt;!-- HTML --&gt;
&lt;div onclick='getAnchor('anchor_1')'&gt;定位到锚点一&lt;/div&gt;
&lt;div onclick='getAnchor('anchor_2')'&gt;定位到锚点二&lt;/div&gt;

&lt;div id='anchor_1'&gt;锚点位置一&lt;/div&gt;
&lt;div id='anchor_2'&gt;锚点位置二&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;!-- JS --&gt;
function getAnchor (id) {
    // 跳转到锚点
    document.getElementById(id).scrollIntoView()
}
</code></pre>
<p>如果需要让页面平滑滚动到指定位置，则需要增加参数 <code>behavior</code> 设置其值为 <code>smooth</code></p>
<pre><code class="language-js">document.documentElement.scrollIntoView({
    behavior: &quot;smooth&quot;,
    block: &quot;start&quot;,
    inline: &quot;nearest&quot;
});
</code></pre>
<h2 id="其他使用场景">其他使用场景</h2>
<p><strong>回到顶部</strong> 也是网页中常用功能。</p>
<p>简单代码实现  <code>document.querySelector('html').scrollIntoView()</code></p>
<h2 id="结语">结语</h2>
<p>本文只是简单介绍了使用方法，想要详细了解的话，可以参考张鑫旭的这篇文章：<a target="_blank" href="https://www.zhangxinxu.com/wordpress/2018/10/scroll-behavior-scrollintoview-%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8/">CSS scroll-behavior 和 JS scrollIntoView 让页面滚动平滑</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac 下 nvm 的安装和使用]]></title>
        <id>https://jiangrubin.github.io/post/mac-xia-nvm-de-an-zhuang-he-shi-yong/</id>
        <link href="https://jiangrubin.github.io/post/mac-xia-nvm-de-an-zhuang-he-shi-yong/">
        </link>
        <updated>2019-12-18T02:48:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在开发中可能同时进行多个项目，而不同的项目所使用的 node 版本又不一样，会导致对现有项目的一些依赖造成环境不兼容等问题。或者要用最新的 node 版本进行学习。所以就需要使用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 来解决这个问题，对多个 node 版本进行管理和切换。</p>
<h2 id="安装">安装</h2>
<p>首先打开终端，进入当前用户的home目录中</p>
<pre><code class="language-shell">cd ~
</code></pre>
<p>使用 <code>ls -a</code> 查看有没有 <code>.bash_profile</code> 这个文件</p>
<pre><code class="language-shell">ls -a
</code></pre>
<p>没有则新建一个</p>
<pre><code class="language-shell">touch ~/.bash_profile
</code></pre>
<p>通过官方的说明在终端中运行下面命令中的一种进行安装</p>
<pre><code class="language-shell">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
</code></pre>
<pre><code class="language-shell">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
</code></pre>
<p>或者使用 <a href="https://brew.sh/">Homebrew</a> 安装 nvm，Homebrew 是 Mac OS 平台下的软件包管理工具。</p>
<p>Homebrew 安装完后，执行命令</p>
<pre><code class="language-shell">brew install nvm 
</code></pre>
<h2 id="验证安装成功">验证安装成功</h2>
<p>重启终端，执行 <code>nvm -v</code> 命令</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1576726689482.jpeg" alt="" loading="lazy"></figure>
<h2 id="常用的-nvm-命令">常用的 nvm 命令</h2>
<p><code>nvm ls-remote</code> 列出所有可安装的版本</p>
<p><code>nvm install &lt;version&gt;</code> 安装指定的版本，如 nvm install v8.12.0</p>
<p><code>nvm uninstall &lt;version&gt;</code> 卸载指定的版本</p>
<p><code>nvm ls</code> 列出所有已经安装的版本</p>
<p><code>nvm use &lt;version&gt;</code> 切换使用指定的版本</p>
<p><code>nvm current</code> 显示当前使用的版本</p>
<p><code>nvm alias default &lt;version&gt;</code> 设置默认node版本</p>
<h2 id="简单使用">简单使用</h2>
<p>在终端执行 <code>node -v</code> 、 <code>nvm ls</code>，查看当前使用的 node 版本。例如我的环境中指向 <code>system</code> 也就是 <code>v12.11.1</code>。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1584193730067.jpeg" alt="" loading="lazy"></figure>
<p>执行 <code>nvm use vx.x.x</code>，即可对当前开发环境中 node 版本进行切换。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.jsdelivr.net/gh/jiangrubin/image-host/1584194043884.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数的防抖和节流]]></title>
        <id>https://jiangrubin.github.io/post/han-shu-de-fang-dou-he-jie-liu/</id>
        <link href="https://jiangrubin.github.io/post/han-shu-de-fang-dou-he-jie-liu/">
        </link>
        <updated>2019-11-28T03:01:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>函数的防抖与节流在项目中有很多的使用场景，本文参考了冴羽的两篇文章。</p>
<h2 id="函数防抖">函数防抖</h2>
<h3 id="概念">概念</h3>
<p>指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。</p>
<blockquote>
<p>举个栗子，坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10 秒钟之后，才会关闭电梯门开始运行，因此“函数防抖”的关键在于，在一个事件发生一定时间之后，才执行特定动作。</p>
</blockquote>
<p>场景代码 html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge, chrome=1&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    #container {
      width: 100%;
      height: 200px;
      line-height: 200px;
      text-align: center;
      color: #fff;
      background-color: #444;
      font-size: 30px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var count = 1;
        var container = document.getElementById('container');

        function getUserAction() {
        container.innerHTML = count++;
        };

        container.onmousemove = debounce(getUserAction, 1000);

        function debounce () {
            ...
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="基础版">基础版</h3>
<p>根据上面的表述，实现第一版的代码：</p>
<pre><code class="language-js">function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
</code></pre>
<p>第一版的代码没什么难点。一个事件在 n 秒内重复触发，会一直清除定时器，等停止触发 n 秒后定时器的方法才会执行。同时也解决了定时器中方法的 this 指向和 JavaScript 在事件处理函数中会提供事件对象 event 参数问题。</p>
<h3 id="立刻执行">立刻执行</h3>
<p>第一版代码事件需要在 n 秒后执行。一个新的需求是希望立刻执行函数，然后等到停止触发 n 秒后，再重新触发执行。</p>
<p>增加 immediate 参数判断是否是立刻执行。</p>
<pre><code class="language-js">function debounce(func, wait, immediate) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);

        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null
            }, wait);
            
            if (callNow) func.apply(this, args) 
        } else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
    }
}
</code></pre>
<h3 id="返回值">返回值</h3>
<p>getUserAction 函数可能是有返回值的，所以这里也需要返回函数的结果。但当 immediate 为 false 的时候，因为使用 setTimeout，在最后 return 的时候值会一直是 undefined。所以只在 immediate 为 true 的时候返回函数的执行结果。</p>
<pre><code class="language-js">function debounce(func, wait, immediate) {
    var timeout, result;

    return function () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);

        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null
            }, wait);
            
            if (callNow) result = func.apply(this, args) 
        } else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
        return result
    }
}
</code></pre>
<h3 id="取消">取消</h3>
<p>实现让用户执行 cancel 方法来取消防抖，当用户再次去触发时又可以立刻执行。</p>
<pre><code class="language-js">function debounce(func, wait, immediate) {
    var timeout, result;

    var debounced = function () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);

        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function () {
                timeout = null
            }, wait);
            
            if (callNow) result = func.apply(this, args) 
        } else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
        return result
    }

    debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = null;
    };

    return debounced
}
</code></pre>
<h2 id="函数节流">函数节流</h2>
<p>概念：限制一个函数在一定时间内只能执行一次。</p>
<blockquote>
<p>举个栗子，坐火车或地铁，过安检的时候，在一定时间（例如10秒）内，只允许一个乘客通过安检入口，以配合安检人员完成安检工作。上例中，每10秒内，仅允许一位乘客通过。分析可知“函数节流”的要点在于，在一定时间之内，限制一个动作只执行一次 。</p>
</blockquote>
<pre><code class="language-js">// func (Function): 要节流的函数
// [wait=0] (number): 需要节流的毫秒
// [options={}] (Object): 选项对象
// [options.leading=true] (boolean): 指定调用在节流开始前
// [options.trailing=true] (boolean): 指定调用在节流结束后
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function () {
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
    };

    var throttled = function () {
        var now = Date.now();
        if (!previous &amp;&amp; options.leading === false) previous = now;

        var remaining = wait - (now - previous);
        context = this;
        args = arguments;

        if (remaining &lt;= 0 || remaining &gt; wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout &amp;&amp; options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };

    throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };

    return throttled;
}
</code></pre>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank">JavaScript 专题之跟着 underscore 学防抖</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank">JavaScript 专题之跟着 underscore 学节流</a></li>
</ul>
]]></content>
    </entry>
</feed>