<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jrb1995.github.io</id>
    <title>Rubin&apos;s Blog</title>
    <updated>2020-02-06T06:07:41.441Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jrb1995.github.io"/>
    <link rel="self" href="https://jrb1995.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jrb1995.github.io/images/avatar.png</logo>
    <icon>https://jrb1995.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Rubin&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Git Commit Message 规范化实践]]></title>
        <id>https://jrb1995.github.io/post/git-commit-message-gui-fan-hua-shi-jian</id>
        <link href="https://jrb1995.github.io/post/git-commit-message-gui-fan-hua-shi-jian">
        </link>
        <updated>2020-02-06T03:21:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在多人协作开发项目时，如果没有规范约束 git commit message，造成各种提交风格五花八门。规范的提交信息能让他人快速了解此次提交的目的，还可以有效的输出 CHANGELOG，对项目的管理至关重要。</p>
<h2 id="commit-message-的格式">Commit message 的格式</h2>
<p>目前应用比较广泛的是 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines" target="_blank">Angular 团队的规范</a>，它的 message 格式如下：</p>
<pre><code class="language-xml">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;BLANK LINE&gt;
&lt;body&gt;
&lt;BLANK LINE&gt;
&lt;footer&gt;
</code></pre>
<p><code>type</code> 用于说明 commit 的类别，可以使用如下：</p>
<ul>
<li>feat：新功能</li>
<li>fix：修复 bug</li>
<li>docs：文档修改</li>
<li>style：格式（不影响代码运行的变动）</li>
<li>refactor：代码重构（即不是新增功能，也不是修改 bug 的代码变动）</li>
<li>perf：优化相关，比如提升性能、体验</li>
<li>test：增加测试</li>
<li>revert：回滚</li>
<li>chore：其他修改，比如构建流程、依赖管理</li>
<li>...</li>
</ul>
<p><code>scope</code> 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同</p>
<p><code>subject</code> 是 commit 目的的简短描述</p>
<p><code>body</code> 是对本次 commit 的详细描述，可以分成多行</p>
<p><code>footer</code> 一些备注，通常是 BREAKING CHANGE 或修复的 bug 的链接</p>
<h2 id="commitizen">Commitizen</h2>
<p>了解规范格式后，就需要通过 <a href="https://github.com/commitizen/cz-cli" target="_blank">Commitizen</a> 借助它提供的 git cz 命令替代我们的 git commit 命令，帮助我们生成符合规范的 commit message</p>
<h3 id="安装">安装</h3>
<p>推荐在本地安装的方式</p>
<pre><code>npm install commitizen --save-dev
</code></pre>
<p>接着为 commitizen 初始化 Adapter</p>
<p>在 npm 5.2+ 你可以使用 <a href="http://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank">npx</a> 来初始化 Adapter</p>
<pre><code>npx commitizen init cz-conventional-changelog --save-dev --save-exact
</code></pre>
<blockquote>
<p>npm &lt; 5.2 可以执行 <code>./node_modules/.bin/commitizen or ./node_modules/.bin/git-cz</code></p>
</blockquote>
<p>并在 package.json 中添加 npm scripts 运行脚本</p>
<p>package.json 会新增如下配置：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;commit&quot;: &quot;git-cz&quot;
},
&quot;devDependencies&quot;: {
    &quot;commitizen&quot;: &quot;^4.0.3&quot;,
    &quot;cz-conventional-changelog&quot;: &quot;^3.1.0&quot;,
},
&quot;config&quot;: {
    &quot;commitizen&quot;: {
      &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;
    }
}
</code></pre>
<p>之后就可以在项目中执行 <code>npm run commit</code> 或者 <code>npx git cz</code>，效果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://jrb1995.github.io/post-images/1580967235373.jpeg" alt="" loading="lazy"></figure>
<h2 id="standard-version-自动生成-changelog">standard-version: 自动生成 CHANGELOG</h2>
<p>使用工具后我们的工程 commit message 应该是符合 Angular 团队那套，这样也便于我们借助 <a href="https://github.com/conventional-changelog/standard-version">standard-version</a> 这样的工具, 自动生成 CHANGELOG</p>
<p>本地安装</p>
<pre><code class="language-shell">npm install standard-version --save-dev
</code></pre>
<p>在 package.json 添加运行脚本</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;release&quot;: &quot;standard-version&quot;
  }
}
</code></pre>
<p>更多使用特性详见其文档</p>
<h2 id="结语">结语</h2>
<p>查看完整的 <a href="https://github.com/jrb1995/standard-commit" target="_blank">demo</a></p>
<p>此文是适合自己的一个简单通用配置，如使用 commitlint 更严格的校验 message 以及其他自定义配置，可见以下参考资料中的链接</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://juejin.im/post/5afc5242f265da0b7f44bee4" target="_blank">优雅的提交你的 Git Commit Message</a></p>
</li>
<li>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank">Commit message 和 Change log 编写指南</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[scrollIntoView 实现页面锚点]]></title>
        <id>https://jrb1995.github.io/post/scrollintoview-shi-xian-ye-mian-mao-dian</id>
        <link href="https://jrb1995.github.io/post/scrollintoview-shi-xian-ye-mian-mao-dian">
        </link>
        <updated>2020-01-30T03:12:12.000Z</updated>
        <summary type="html"><![CDATA[<p>锚点即指html中的链接，在页面中适当的添加锚点可以大大提高阅读或查找效率</p>
]]></summary>
        <content type="html"><![CDATA[<p>锚点即指html中的链接，在页面中适当的添加锚点可以大大提高阅读或查找效率</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>锚点是网站中常用的功能。前端简单实现锚点的方法，使用 a 标签把 href 属性写成要跳转到的元素 id，比如以下代码：</p>
<pre><code class="language-html">&lt;a href=&quot;#anchor&quot;&gt;&lt;/a&gt;

&lt;div id=&quot;anchor&quot;&gt;&lt;/div&gt;
</code></pre>
<p>点击 a 标签页面就会跳转到指定 id 元素的位置。并改变链接地址比如：<code>http://www.xxxx.com#anchor</code>。</p>
<p>虽然不会有什么问题，直接跳转过去立马完成产品的需求，但是当网页中存在多个锚点时，就会出现点击浏览器后退按钮并不会返回之前浏览的网页，而是返回上一个带有锚点的链接。</p>
<blockquote>
<p>举个例子，当前网站链接是 <code>http://www.xxxx.com#anchor2</code>， 当用户想返回之前的页面，点击后退按钮后，链接变成了 <code>http://www.xxxx.com#anchor1</code>。但还是在同一个页面中，会使用户感到迷惑，降低用户体验。</p>
</blockquote>
<h2 id="解决问题">解决问题</h2>
<p><code>scrollIntoView()</code> 方法让当前的元素滚动到浏览器窗口的可视区域内，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollIntoView">MDN</a> 对此方法介绍。</p>
<p>简单代码实现：</p>
<pre><code class="language-html">&lt;!-- HTML --&gt;
&lt;div onclick='getAnchor('anchor_1')'&gt;定位到锚点一&lt;/div&gt;
&lt;div onclick='getAnchor('anchor_2')'&gt;定位到锚点二&lt;/div&gt;

&lt;div id='anchor_1'&gt;锚点位置一&lt;/div&gt;
&lt;div id='anchor_2'&gt;锚点位置二&lt;/div&gt;
</code></pre>
<pre><code class="language-js">&lt;!-- JS --&gt;
function getAnchor (id) {
    // 跳转到锚点
    document.getElementById(id).scrollIntoView()
}
</code></pre>
<p>如果需要让页面平滑滚动到指定位置，则需要增加参数 <code>behavior</code> 设置其值为 <code>smooth</code></p>
<pre><code class="language-js">document.documentElement.scrollIntoView({
    behavior: &quot;smooth&quot;,
    block: &quot;start&quot;,
    inline: &quot;nearest&quot;
});
</code></pre>
<h2 id="其他使用场景">其他使用场景</h2>
<p><strong>回到顶部</strong> 也是网页中常用功能。</p>
<p>简单代码实现  <code>document.querySelector('html').scrollIntoView()</code></p>
<h2 id="结语">结语</h2>
<p>本文只是简单介绍了使用方法，想要详细了解的话，可以参考张鑫旭的这篇文章：<a target="_blank" href="https://www.zhangxinxu.com/wordpress/2018/10/scroll-behavior-scrollintoview-%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8/">CSS scroll-behavior 和 JS scrollIntoView 让页面滚动平滑</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac 下 nvm 的安装和使用]]></title>
        <id>https://jrb1995.github.io/post/mac-xia-nvm-de-an-zhuang-he-shi-yong</id>
        <link href="https://jrb1995.github.io/post/mac-xia-nvm-de-an-zhuang-he-shi-yong">
        </link>
        <updated>2019-12-18T02:48:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在开发中可能同时进行多个项目，而不同的项目所使用的 node 版本又不一样，会导致对现有项目的一些依赖造成环境不兼容等问题。或者要用最新的 node 版本进行学习。所以就需要使用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 来解决这个问题，对多个 node 版本进行管理和切换。</p>
<h2 id="安装">安装</h2>
<p>首先打开终端，进入当前用户的home目录中</p>
<pre><code class="language-shell">cd ~
</code></pre>
<p>使用 <code>ls -a</code> 查看有没有 <code>.bash_profile</code> 这个文件</p>
<pre><code class="language-shell">ls -a
</code></pre>
<p>没有则新建一个</p>
<pre><code class="language-shell">touch ~/.bash_profile
</code></pre>
<p>通过官方的说明在终端中运行下面命令中的一种进行安装</p>
<pre><code class="language-shell">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
</code></pre>
<pre><code class="language-shell">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
</code></pre>
<p>或者使用 <a href="https://brew.sh/">Homebrew</a> 安装 nvm，Homebrew 是 Mac OS 平台下的软件包管理工具。</p>
<p>Homebrew 安装完后，执行命令</p>
<pre><code class="language-shell">brew install nvm 
</code></pre>
<h2 id="验证安装成功">验证安装成功</h2>
<p>重启终端，执行 <code>nvm -v</code> 命令</p>
<figure data-type="image" tabindex="1"><img src="https://jrb1995.github.io/post-images/1576726689482.jpeg" alt="" loading="lazy"></figure>
<h2 id="常用的-nvm-命令">常用的 nvm 命令</h2>
<p><code>nvm ls-remote</code> 列出所有可安装的版本</p>
<p><code>nvm install &lt;version&gt;</code> 安装指定的版本，如 nvm install v8.12.0</p>
<p><code>nvm uninstall &lt;version&gt;</code> 卸载指定的版本</p>
<p><code>nvm ls</code> 列出所有已经安装的版本</p>
<p><code>nvm use &lt;version&gt;</code> 切换使用指定的版本</p>
<p><code>nvm current</code> 显示当前使用的版本</p>
<p><code>nvm alias default &lt;version&gt;</code> 设置默认node版本</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数的防抖和节流]]></title>
        <id>https://jrb1995.github.io/post/han-shu-de-fang-dou-he-jie-liu</id>
        <link href="https://jrb1995.github.io/post/han-shu-de-fang-dou-he-jie-liu">
        </link>
        <updated>2019-11-28T03:01:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概念">概念</h2>
<p><strong>函数防抖</strong>：指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。</p>
<blockquote>
<p>举个栗子，坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10 秒钟之后，才会关闭电梯门开始运行，因此“函数防抖”的关键在于，在一个事件发生一定时间之后，才执行特定动作。</p>
</blockquote>
<p><strong>函数节流</strong>：限制一个函数在一定时间内只能执行一次。</p>
<blockquote>
<p>举个栗子，坐火车或地铁，过安检的时候，在一定时间（例如10秒）内，只允许一个乘客通过安检入口，以配合安检人员完成安检工作。上例中，每10秒内，仅允许一位乘客通过。分析可知“函数节流”的要点在于，在一定时间之内，限制一个动作只执行一次 。</p>
</blockquote>
<p>实际开发中经常会遇到通过鼠标和输入框等连续触发目标函数，如果其中与后端进行交互，比如 <code>ajax</code> 请求。就会频繁请求对后台造成一些压力。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="防抖-debounce">防抖 debounce</h3>
<pre><code class="language-js">// 函数防抖（连续事件触发结束后只触发一次）
// sample 1: _.debounce(function(){}, 1000)
// 连续事件结束后的 1000ms 后触发
// sample 1: _.debounce(function(){}, 1000, true)
// 连续事件触发后立即触发（此时会忽略第二个参数）
function debounce(func, wait, immediate) {
  var timeout, args, context, timestamp, result

  var later = function () {
    var last = Date.now() - timestamp
    if (last &lt; wait &amp;&amp; last &gt;= 0) {
      timeout = setTimeout(later, wait - last)
    } else {
      timeout = null
      if (!immediate) {
        result = func.apply(context, args)
        if (!timeout) { context = args = null }
      }
    }
  }

  return function () {
    context = this
    args = arguments
    timestamp = Date.now()
    var callNow = immediate &amp;&amp; !timeout

    if (!timeout) {
      timeout = setTimeout(later, wait)
    }

    if (callNow) {
      result = func.apply(context, args)
      context = args = null
    }

    return result
  }
}
</code></pre>
<h3 id="节流-throttle">节流 throttle</h3>
<pre><code class="language-js">// 函数节流（如果有连续事件响应，则每间隔一定时间段触发）
// 每间隔 wait(Number) milliseconds 触发一次 func 方法
// 如果 options 参数传入 {leading: false}
// 那么不会马上触发（等待 wait milliseconds 后第一次触发 func）
// 如果 options 参数传入 {trailing: false}
// 那么最后一次回调不会被触发
// **Notice: options 不能同时设置 leading 和 trailing 为 false**
// 示例：
// var throttled = _.throttle(updatePosition, 100);
// $(window).scroll(throttled);
// 调用方式（注意看 A 和 B console.log 打印的位置）：
// _.throttle(function, wait, [options])
// sample 1: _.throttle(function(){}, 1000)
// print: A, B, B, B ...
// sample 2: _.throttle(function(){}, 1000, {leading: false})
// print: B, B, B, B ...
// sample 3: _.throttle(function(){}, 1000, {trailing: false})
// print: A, A, A, A ...
// ----------------------------------------- //
function throttle(func, wait, options) {
  var context, args, result
  var timeout = null
  var previous = 0

  if (!options) { options = {} }

  var later = function () {
    previous = options.leading === false ? 0 : Date.now()
    timeout = null
    result = func.apply(context, args)
    if (!timeout) { context = args = null }
  }

  return function () {
    var now = Date.now()
    if (!previous &amp;&amp; options.leading === false) { previous = now }

    var remaining = wait - (now - previous)
    context = this
    args = arguments

    if (remaining &lt;= 0 || remaining &gt; wait) {
      if (timeout) {
        clearTimeout(timeout)
        timeout = null
      }
      previous = now
      result = func.apply(context, args)
      if (!timeout) { context = args = null }
    } else if (!timeout &amp;&amp; options.trailing !== false) {
      timeout = setTimeout(later, remaining)
    }

    return result
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS开发技巧整理]]></title>
        <id>https://jrb1995.github.io/post/5dc8a231f268da4d40712f8a</id>
        <link href="https://jrb1995.github.io/post/5dc8a231f268da4d40712f8a">
        </link>
        <updated>2019-11-11T13:15:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="快速重置表单元素">快速重置表单元素</h3>
<p>原始的 <code>button</code> 按钮重置</p>
<pre><code class="language-css">button {
  background: none;
  border: none;
  color: inherit;
  font: inherit;
  outline: none;
  padding: 0;
}
</code></pre>
<p>只需要这样就可以(<code>input</code>、<code>textarea</code>)</p>
<pre><code class="language-css">button { 
  all: unset;
}
</code></pre>
<h3 id="文本省略号显示">文本省略号显示</h3>
<p>文本省略号是非常常见的需求，而省略号展示又通常分为俩种情况折行和不折行。</p>
<p>不折行：</p>
<pre><code class="language-css">div {  
  white-space: nowrap; /* 规定文本是否折行 */  
  overflow: hidden; /* 规定超出内容宽度的元素隐藏 */
  text-overflow: ellipsis; /* 规定超出的内容文本省略号显示，通常跟上面的属性连用，因为没有上面的属性不会触发超出规定的内容 */
}
</code></pre>
<p>折行(能主动控制行数,这里设置的超出 4 行显示省略号)：</p>
<pre><code class="language-css">div {      
  overflow: hidden;      
  text-overflow: ellipsis;      
  display: -webkit-box; /* 将对象作为弹性伸缩盒子模型显示 */      
  -webkit-line-clamp: 4; /* 控制最多显示几行 */      
  -webkit-box-orient: vertical; /* 设置或检索伸缩盒对象的子元素的排列方式 */    
}
</code></pre>
<h3 id="设置文本两端对齐">设置文本两端对齐</h3>
<pre><code class="language-css">p {
  text-align-last: justify; /* 这是关键属性 */
}
</code></pre>
<h3 id="规定图像展示方式">规定图像展示方式</h3>
<p>显示图片的时候会遇到这种问题，对面返回的图片宽高比例是不一样的。但是设置的容器大小是一样的，这个时候需要让图片保持比例最大填充容器。</p>
<pre><code>object-fit： cover | contain | fill | scale-down | none
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://jrb1995.github.io/post-images/1573479048374.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Native 知识点小记]]></title>
        <id>https://jrb1995.github.io/post/react-native</id>
        <link href="https://jrb1995.github.io/post/react-native">
        </link>
        <updated>2019-04-08T12:29:48.000Z</updated>
        <summary type="html"><![CDATA[<p>此篇文章用于记录开发中遇到的问题和知识点...</p>
]]></summary>
        <content type="html"><![CDATA[<p>此篇文章用于记录开发中遇到的问题和知识点...</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>公司打算开发一个App项目。由于没有原生开发人员，组里都是纯前端开发人员，所以技术选型时采用相对成熟的 <code>react-native</code> 来开发。不得不说 <code>react-native</code> 确实很优秀，让前端开发人员能够迅速搭起一个应用运行。但开发过程中也遇到了不少问题，对前端开发来说也是一个不小的挑战。</p>
<h2 id="开发环境搭建">开发环境搭建</h2>
<p>只要严格按照 <a href="https://reactnative.cn/docs/getting-started/">React Native</a> 官方文档搭建即可，当时项目使用 <code>react-native</code> 0.57 版本基础库。</p>
<h2 id="应用设置">应用设置</h2>
<p>应用名称、图标、启动屏相关设置</p>
<h3 id="修改应用名称">修改应用名称</h3>
<ul>
<li>iOS</li>
</ul>
<p>编辑 <code>ios/项目名称/Info.plist</code> 文件：</p>
<pre><code class="language-xml">&lt;key&gt;CFBundleDisplayName&lt;/key&gt;
- &lt;string&gt;$(PRODUCT_NAME)&lt;/string&gt;
+ &lt;string&gt;应用名称&lt;/string&gt;
</code></pre>
<ul>
<li>android</li>
</ul>
<p>编辑 <code>android/app/src/main/res/values/strings.xml</code> 文件：</p>
<pre><code class="language-xml">&lt;resources&gt;
- &lt;string name=&quot;app_name&quot;&gt;default&lt;/string&gt;
+ &lt;string name=&quot;app_name&quot;&gt;应用名称&lt;/string&gt;   
&lt;/resources&gt;
</code></pre>
<h3 id="修改图标">修改图标</h3>
<p>应用图标对尺寸有要求。比较简单地方式是准备一张 <code>1024*1024</code> 的图片，然后使用 <a href="https://icon.wuruihong.com/">图标工厂</a> 在线生成。</p>
<p>生成文件如下：</p>
<figure data-type="image" tabindex="1"><img src="https://jrb1995.github.io/post-images/1573218973706.jpg" alt="" loading="lazy"></figure>
<ul>
<li>iOS</li>
</ul>
<p>替换 <code>ios/项目名称/Images.xcassets/AppIcon.appiconset</code> 中的内容。如果不需要全部尺寸可以用 <code>XCode</code> 打开项目 <code>Images.xcassets</code> &gt; <code>AppIcon</code> 拖入相应尺寸的图标。</p>
<ul>
<li>android</li>
</ul>
<p>替换 <code>android/app/src/main/res</code> 下对应的图标。</p>
<h3 id="添加启动页">添加启动页</h3>
<p>应用打开时会有短暂的白屏，为解决这一问题项目中使用 <a href="https://github.com/crazycodeboy/react-native-splash-screen">react-native-splash-screen</a> 库。文档写的很详细。</p>
<p><a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/launch-screen/">Launch Screen苹果官方分辨率大全</a></p>
<h2 id="功能组件">功能组件</h2>
<h3 id="icon-组件">Icon 组件</h3>
<p>关于 <code>svg</code> 文件的优点就不必多说了。要想在应用中使用会有一些问题，不像在 web 中直接 img 标签引入就可以用了。比如安卓不支持 svg 静态文件的 require 😂。也为了避免每次打开应用请求多个 svg 浪费资源。</p>
<p>所以可以将多个 svg 文件通过脚本转换成一个 js 对象或者一个 json 文件，其格式如下：</p>
<pre><code class="language-js">export default {
  &quot;arrow-left&quot;: &quot;&lt;svg&gt;...&lt;/svg&gt;&quot;
}
</code></pre>
<p>上面的转换脚本可以参考 <a href="https://github.com/HuJiaoHJ/svg2json">svg2json</a></p>
<p>安装</p>
<pre><code class="language-shell">npm install react-native-svg2json --save-dev
</code></pre>
<p>在项目根目录输入命令如下：</p>
<pre><code class="language-shell">// svg2json -i ${inDir} -o ${outFile}
./node_modules/.bin/svg2json -i ./src/assets/svgs -o ./src/assets/svgs.js
</code></pre>
<p>或者写入 <code>package.json</code> scripts 中，直接运行 <code>npm run svg2json</code></p>
<pre><code class="language-js">&quot;scripts&quot;: {
    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;,
    &quot;test&quot;: &quot;jest&quot;,
    &quot;svg2json&quot;: &quot;node node_modules/.bin/svg2json -i ./src/assets/svgs -o ./src/assets/svgs.js&quot;
}
</code></pre>
<p>之后如何使用，就需要 <a href="https://github.com/vault-development/react-native-svg-uri">react-native-svg-uri</a> 库，支持传入 svg 字符串来渲染 svg。但还需做好组件封装。</p>
<pre><code class="language-js">import React, { Component } from 'react';
import SvgUri from 'react-native-svg-uri';
import svgs from '@/assets/svgs.js'; // 生成的 svg 字符串对象
export default class Icon extends Component {
  render() {
    const { name, color, size, style } = this.props;
    let svgXmlData = svgs[name]
    if (!svgXmlData) {
      let err_msg = `没有&quot;${name}&quot;这个icon文件`;
      throw new Error(err_msg);
    }
    return (
      &lt;SvgUri width={size} height={size} svgXmlData={svgXmlData} fill={color} style={style} /&gt;
    )
  }
}
</code></pre>
<p>使用</p>
<pre><code class="language-js">&lt;Icon name=&quot;ac_unit&quot; size=&quot;40&quot; color=&quot;#ccc&quot;/&gt;
</code></pre>
<h2 id="路径别名">路径别名</h2>
<p>在开发过程中通常使用 <code>../../../</code> 的方式引入组件，这种方式路径过深且不够优雅。</p>
<p>插件安装</p>
<pre><code class="language-shell">npm install babel-plugin-root-import --save-dev
或者
yarn add babel-plugin-root-import --dev
</code></pre>
<p>在 <code>babel</code> 配置文件 <code>.babelrc</code> 或者 <code>babel.config.js</code> 中</p>
<pre><code class="language-js">{
  &quot;plugins&quot;: [
    [&quot;babel-plugin-root-import&quot;, {
      &quot;rootPathPrefix&quot;: &quot;~&quot;,
      &quot;rootPathSuffix&quot;: &quot;src&quot;
    }]
  ]
}
</code></pre>
<blockquote>
<p>注意： 当 rootPathPrefix 设置为 @ 可能会导致一些以 @ 开头的 npm 包引入错误，如 <code>@ant-design/react-native</code></p>
</blockquote>
<p>之后使用</p>
<pre><code class="language-js">import foo from '~/foo';
const bar = require('~/bar');
</code></pre>
<h2 id="打包和发布">打包和发布</h2>
<p>应用开发完就该考虑上架了😘，由于没有经验上网查询了很多资料。</p>
<p>链接：<a href="https://my.oschina.net/KJhulinhua/blog/1585628">react native ios打包流程</a>、<a href="https://www.pgyer.com/doc/view/build_ipa">打包iOS的ipa文件</a>、<a href="https://www.jianshu.com/p/431ed0536754">iOS生成证书 描述文件 打包上架Appstore详细流程</a></p>
<h2 id="其他问题">其他问题</h2>
<p>android 图片不显示，图片名称不能是中文（开发时碰到这个问题😓）。</p>
<h2 id="其他知识资源">其他知识资源</h2>
<p><a href="https://juejin.im/post/5c5402f8f265da2dbd7fd084">https://juejin.im/post/5c5402f8f265da2dbd7fd084</a></p>
]]></content>
    </entry>
</feed>